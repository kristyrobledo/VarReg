}
}
if (is.null(mean.ind[1])==TRUE){
#print("test param")
param<-length(totalx)+1
}else if (mean.ind[1]==0){
param<-1+length(totalx)+1
}else{
param<-length(mean.ind)+1+length(totalx)+1
}
if (sum(as.integer(loops[[max.ll]]$p.old < eps))>0){
boundary=TRUE
}else{
boundary=FALSE
}
aicc<-(2*(param)*n)/(n-(param)-1)-2*ll.final
aic<-2*(param)-2*ll.final
bic<-log(n)*(param)-2*ll.final
hqc<-log(log(n))*(param)-2*ll.final
list(conv=conv.final,iterations=it.final,reldiff=reldiff.final, loglikelihood=ll.final, boundary=boundary, AICc=aicc, AIC=aic,BIC=bic,HQC=hqc,mean.ind=mean.ind,mean=mean,var.ind=var.ind, variance=alpha, data=dat)
}
data(lidar)
linmodel<-linVarReg(lidar, var.ind=c(2),mean.ind=c(2), para.space=FALSE)
warnings()
dat=lidar
var.ind=c(2)
mean.ind=c(2)
para.space=FALSE
eps=1e-6
maxit=1000
if (para.space==FALSE || para.space=="negative" || para.space=="positive"){
#print("OK")
}else{stop("para.space not appropriately defined. See help.")
}
loops<-list()
ll<-vector()
X<-dat[,1]
n<-length(X)
totalx<-var.ind
if (is.null(mean.ind[1])==TRUE){
meanmodel<-NULL
}else if(mean.ind[1]==0){
meanmodel<-FALSE
}else if (mean.ind[1]>0){
meanmodel<-data.frame(dat[,mean.ind])
}
minmax<-list()
x<-as.matrix(dat[,var.ind])
theta.old<-rep(1, 1+length(var.ind))
minmax[[1]]<-c("Min", "Max")
##find all combinations that need to be performed
if (para.space==FALSE){
comb<-expand.grid(rep(minmax, times=length(var.ind)))
}else if(para.space=="negative"){
comb<-as.data.frame(matrix(c(rep("Min", length(rep))), 1, length(totalx), byrow=TRUE))
}else if(para.space=="positive"){
comb<-as.data.frame(matrix(c(rep("Max", length(rep))), 1, length(totalx), byrow=TRUE))
}
for (i in 1:nrow(comb)){
p.old<-rep(theta.old[1], n)
x.0<-matrix(NA, ncol=ncol(x), nrow=nrow(x) )
for (j in 1:ncol(comb)){
if(comb[i,j]=="Min"){
x.0[,j]<-x[,j]-min(x[,j])
p.old<-p.old+(theta.old[j]*x.0[,j])
}
if(comb[i,j]=="Max"){
x.0[,j]<-max(x[,j])-x[,j]
p.old<-p.old+(theta.old[j]*x.0[,j])
}
}
loops[[i]]<-loop_em(meanmodel, theta.old, p.old, x.0, X, maxit, eps)
ll[i]<- -n/2*log(2*pi)-1/2*sum(log(loops[[i]]$p.old))-sum(((X-loops[[i]]$fittedmean)**2)/(2*(loops[[i]]$p.old)))
if (loops[[i]]$conv==FALSE){
writeLines(paste("Warning: Did not converge at maxit=", maxit))
}
}
}
warnings()
minmax<-list()
x<-as.matrix(dat[,var.ind])
theta.old<-rep(1, 1+length(var.ind))
minmax[[1]]<-c("Min", "Max")
##find all combinations that need to be performed
if (para.space==FALSE){
comb<-expand.grid(rep(minmax, times=length(var.ind)))
}else if(para.space=="negative"){
comb<-as.data.frame(matrix(c(rep("Min", length(rep))), 1, length(totalx), byrow=TRUE))
}else if(para.space=="positive"){
comb<-as.data.frame(matrix(c(rep("Max", length(rep))), 1, length(totalx), byrow=TRUE))
}
i=1
p.old<-rep(theta.old[1], n)
x.0<-matrix(NA, ncol=ncol(x), nrow=nrow(x) )
for (j in 1:ncol(comb)){
if(comb[i,j]=="Min"){
x.0[,j]<-x[,j]-min(x[,j])
p.old<-p.old+(theta.old[j]*x.0[,j])
}
if(comb[i,j]=="Max"){
x.0[,j]<-max(x[,j])-x[,j]
p.old<-p.old+(theta.old[j]*x.0[,j])
}
}
comb
n<-length(X)
Z2<-list()
R2<-list()
conv<-FALSE
it<-NULL
theta.new<-theta.old
n
if (is.null(meanmodel)==TRUE){
mean.fit<-rep(0,n)
beta.old<-NULL
}else if (meanmodel[1]==FALSE && is.null(meanmodel)==FALSE){
l<-lm(X~1, weight=1/p.old)
beta.old<-l$coeff
mean.fit<-l$fitted
}else if (meanmodel[1]!=FALSE && is.null(meanmodel)==FALSE){
l<-lm(X~., weight=1/p.old, data=meanmodel)
beta.old<-l$coeff
mean.fit<-l$fitted
}
beta.new<-beta.old
X0<-X-mean.fit
Y2<-theta.old[1]+(theta.old[1]**2/p.old)*(X0**2/p.old - 1)
theta.new[1]<-mean(Y2)
if (!is.null(x.0)){
Z2<-sapply(1:ncol(x.0),function(x) x.0[,x]*theta.old[x+1]+((theta.old[x+1]*x.0[,x])**2/p.old)*(X0**2/p.old-1))
theta.new[-1]<-sapply(1:ncol(x.0), function(x) mean(Z2[,x]/x.0[,x],na.rm=TRUE ))
}
wt=1/p.old
wt[wt > 1e10] <- 1e10
##calculate weighted mean - weighted by inverse variance FROM LM WEIGHTED MODEL
if (meanmodel[1]==FALSE && is.null(meanmodel)==FALSE){
l<-lm(X~1, weight=wt)
mean.fit<-l$fitted
beta.new<-l$coeff
}else if (meanmodel[1]!=FALSE && is.null(meanmodel)==FALSE){
l<-lm(X~., weight=wt, data=meanmodel)
mean.fit<-l$fitted
beta.new<-l$coeff
}
#' The EM loop
#'
#' \code{loop_em} is a basic EM loop function to be utilised by various other higher level functions
#' @param meanmodel Dataframe containing only the covariates to be fit in the mean model. NULL for zero mean model and FALSE for constant mean model.
#' @param theta.old Vector containing the initial variance parameter estimates to be fit in the variance model.
#' @param p.old Vector of length n containing the containing the initial variance estimate.
#' @param x.0 Matrix of covariates (length n) to be fit in the variance model. All have been rescaled so zero is the minimum. If NULL, then its a constant variance model.
#' @param X Vector of length n of the outcome variable.
#' @param maxit Number of maximum iterations for the EM algorithm, default 1000.
#' @param eps Very small number for the convergence criteria, default 1 times 10 power6
#' @return A list of the results from the EM algorithm, including conv, reldiff, it, mean, theta.new, fitted.
#'
loop_em<-function(meanmodel, theta.old, p.old, x.0, X, maxit, eps){
n<-length(X)
Z2<-list()
R2<-list()
conv<-FALSE
it<-NULL
theta.new<-theta.old
if (is.null(meanmodel)==TRUE){
mean.fit<-rep(0,n)
beta.old<-NULL
}else if (meanmodel[1]==FALSE && is.null(meanmodel)==FALSE){
l<-lm(X~1, weight=1/p.old)
beta.old<-l$coeff
mean.fit<-l$fitted
}else if (meanmodel[1]!=FALSE && is.null(meanmodel)==FALSE){
l<-lm(X~., weight=1/p.old, data=meanmodel)
beta.old<-l$coeff
mean.fit<-l$fitted
}
beta.new<-beta.old
for (q in 1:maxit) {
it<-q
X0<-X-mean.fit
Y2<-theta.old[1]+(theta.old[1]**2/p.old)*(X0**2/p.old - 1)
theta.new[1]<-mean(Y2)
if (!is.null(x.0)){
Z2<-sapply(1:ncol(x.0),function(x) x.0[,x]*theta.old[x+1]+((theta.old[x+1]*x.0[,x])**2/p.old)*(X0**2/p.old-1))
theta.new[-1]<-sapply(1:ncol(x.0), function(x) mean(Z2[,x]/x.0[,x],na.rm=TRUE ))
}
##calculate weighting for next LM - bounded at 1e10
wt=1/p.old
wt[wt > 1e10] <- 1e10
##calculate weighted mean - weighted by inverse variance FROM LM WEIGHTED MODEL
if (meanmodel[1]==FALSE && is.null(meanmodel)==FALSE){
l<-lm(X~1, weight=wt)
mean.fit<-l$fitted
beta.new<-l$coeff
}else if (meanmodel[1]!=FALSE && is.null(meanmodel)==FALSE){
l<-lm(X~., weight=wt, data=meanmodel)
mean.fit<-l$fitted
beta.new<-l$coeff
}
reldiff<-sqrt(sum((c(theta.new,beta.new)-c(theta.old,beta.old))**2)/sum(c(beta.old,theta.old))**2)
theta.old<-theta.new
beta.old<-beta.new
p.old<-rep(theta.old[1], n)
if (!is.null(x.0)){
p.old<-rowSums(cbind(rep(theta.new[1], n),sapply(1:ncol(x.0), function(x) theta.new[x+1]*x.0[,x])))
}
if (is.finite(reldiff)==TRUE){
if (reldiff<eps){
conv<-TRUE
break
}
}
}
list(conv=conv, reldiff=reldiff, it=it, mean=beta.new, theta.new=theta.new, fittedmean=mean.fit, p.old=p.old)
}
loops[[i]]<-loop_em(meanmodel, theta.old, p.old, x.0, X, maxit, eps)
loops
linVarReg<-function(dat, var.ind=c(2), mean.ind=c(2), para.space=FALSE, eps=1e-6, maxit=1000){
if (para.space==FALSE || para.space=="negative" || para.space=="positive"){
#print("OK")
}else{stop("para.space not appropriately defined. See help.")
}
loops<-list()
ll<-vector()
X<-dat[,1]
n<-length(X)
totalx<-var.ind
if (is.null(mean.ind[1])==TRUE){
meanmodel<-NULL
}else if(mean.ind[1]==0){
meanmodel<-FALSE
}else if (mean.ind[1]>0){
meanmodel<-data.frame(dat[,mean.ind])
}
### constant variance first
if (var.ind[1]==FALSE){
loops[[1]]<-loop_em(meanmodel, theta.old=1, p.old=rep(1, n), x.0=NULL, X, maxit, eps)
var<- rep(loops[[1]]$theta.new, n)
ll<- -n/2*log(2*pi)-1/2*sum(log(var))-sum(((X-loops[[1]]$fitted)**2)/(2*(var)))
if (loops[[1]]$conv==FALSE){
writeLines(paste("Warning: Did not converge at Maxit=", maxit))
}
##variance model option
}else{
## set parameters
minmax<-list()
x<-as.matrix(dat[,var.ind])
theta.old<-rep(1, 1+length(var.ind))
minmax[[1]]<-c("Min", "Max")
##find all combinations that need to be performed
if (para.space==FALSE){
comb<-expand.grid(rep(minmax, times=length(var.ind)))
}else if(para.space=="negative"){
comb<-as.data.frame(matrix(c(rep("Min", length(rep))), 1, length(totalx), byrow=TRUE))
}else if(para.space=="positive"){
comb<-as.data.frame(matrix(c(rep("Max", length(rep))), 1, length(totalx), byrow=TRUE))
}
for (i in 1:nrow(comb)){
p.old<-rep(theta.old[1], n)
x.0<-matrix(NA, ncol=ncol(x), nrow=nrow(x) )
for (j in 1:ncol(comb)){
if(comb[i,j]=="Min"){
x.0[,j]<-x[,j]-min(x[,j])
p.old<-p.old+(theta.old[j]*x.0[,j])
}
if(comb[i,j]=="Max"){
x.0[,j]<-max(x[,j])-x[,j]
p.old<-p.old+(theta.old[j]*x.0[,j])
}
}
loops[[i]]<-loop_em(meanmodel, theta.old, p.old, x.0, X, maxit, eps)
ll[i]<- -n/2*log(2*pi)-1/2*sum(log(loops[[i]]$p.old))-sum(((X-loops[[i]]$fittedmean)**2)/(2*(loops[[i]]$p.old)))
if (loops[[i]]$conv==FALSE){
writeLines(paste("Warning: Did not converge at maxit=", maxit))
}
}
}
##find highest LL for both constant and nonconstant!
max.ll<-which.max(ll)
alpha<-vector()
##save all estimates
alpha[1]<- loops[[max.ll]]$theta.new[1]
conv.final<-loops[[max.ll]]$conv
it.final<-loops[[max.ll]]$it
reldiff.final<-loops[[max.ll]]$reldiff
ll.final<-ll[[max.ll]]
mean<-loops[[max.ll]]$mean
if (var.ind!=FALSE){
for (j in 1:ncol(comb)){
if(comb[max.ll,j]=="Min"){
alpha[1]<-alpha[1]-loops[[max.ll]]$theta.new[j+1]*min(x[,j])
alpha[j+1]<- loops[[max.ll]]$theta.new[j+1]
}
if(comb[max.ll,j]=="Max"){
alpha[1]<-alpha[1]+loops[[max.ll]]$theta.new[j+1]*max(x[,j])
alpha[j+1]<- -loops[[max.ll]]$theta.new[j+1]
}
}
}
if (is.null(mean.ind[1])==TRUE){
#print("test param")
param<-length(totalx)+1
}else if (mean.ind[1]==0){
param<-1+length(totalx)+1
}else{
param<-length(mean.ind)+1+length(totalx)+1
}
if (sum(as.integer(loops[[max.ll]]$p.old < eps))>0){
boundary=TRUE
}else{
boundary=FALSE
}
aicc<-(2*(param)*n)/(n-(param)-1)-2*ll.final
aic<-2*(param)-2*ll.final
bic<-log(n)*(param)-2*ll.final
hqc<-log(log(n))*(param)-2*ll.final
list(conv=conv.final,iterations=it.final,reldiff=reldiff.final, loglikelihood=ll.final, boundary=boundary, AICc=aicc, AIC=aic,BIC=bic,HQC=hqc,mean.ind=mean.ind,mean=mean,var.ind=var.ind, variance=alpha, data=dat)
}
data(lidar)
linmodel<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=c(2), para.space=FALSE)
linmodel
data(lidar)
lid<-data.frame(lidar$logratio, lidar$range)
linmodel<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=c(2), para.space=FALSE)
linmode;
linmodel
library(VarReg)
linmodel<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=c(2), para.space=FALSE, maxit=10000)
linmodel
conmean<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=0)
linmodel<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=c(2), maxit=10000)
conmean
data(lidar)
<-data.frame(lidar$logratio, lidar$range)
dat<-data.frame(lidar$logratio, lidar$range)
var.ind=c(2)
mean.ind=c(2)
para.space=FALSE
eps=1e-6
maxit=1000
loops<-list()
ll<-vector()
X<-dat[,1]
n<-length(X)
totalx<-var.ind
if (is.null(mean.ind[1])==TRUE){
meanmodel<-NULL
}else if(mean.ind[1]==0){
meanmodel<-FALSE
}else if (mean.ind[1]>0){
meanmodel<-data.frame(dat[,mean.ind])
}
### constant variance first
if (var.ind[1]==FALSE){
loops[[1]]<-loop_em(meanmodel, theta.old=1, p.old=rep(1, n), x.0=NULL, X, maxit, eps)
var<- rep(loops[[1]]$theta.new, n)
ll<- -n/2*log(2*pi)-1/2*sum(log(var))-sum(((X-loops[[1]]$fitted)**2)/(2*(var)))
if (loops[[1]]$conv==FALSE){
writeLines(paste("Warning: Did not converge at Maxit=", maxit))
}
##variance model option
}else{
## set parameters
minmax<-list()
x<-as.matrix(dat[,var.ind])
theta.old<-rep(1, 1+length(var.ind))
minmax[[1]]<-c("Min", "Max")
##find all combinations that need to be performed
if (para.space==FALSE){
comb<-expand.grid(rep(minmax, times=length(var.ind)))
}else if(para.space=="negative"){
comb<-as.data.frame(matrix(c(rep("Min", length(rep))), 1, length(totalx), byrow=TRUE))
}else if(para.space=="positive"){
comb<-as.data.frame(matrix(c(rep("Max", length(rep))), 1, length(totalx), byrow=TRUE))
}
for (i in 1:nrow(comb)){
p.old<-rep(theta.old[1], n)
x.0<-matrix(NA, ncol=ncol(x), nrow=nrow(x) )
for (j in 1:ncol(comb)){
if(comb[i,j]=="Min"){
x.0[,j]<-x[,j]-min(x[,j])
p.old<-p.old+(theta.old[j]*x.0[,j])
}
if(comb[i,j]=="Max"){
x.0[,j]<-max(x[,j])-x[,j]
p.old<-p.old+(theta.old[j]*x.0[,j])
}
}
loops[[i]]<-loop_em(meanmodel, theta.old, p.old, x.0, X, maxit, eps)
ll[i]<- -n/2*log(2*pi)-1/2*sum(log(loops[[i]]$p.old))-sum(((X-loops[[i]]$fittedmean)**2)/(2*(loops[[i]]$p.old)))
if (loops[[i]]$conv==FALSE){
writeLines(paste("Warning: Did not converge at maxit=", maxit))
}
}
}
X
x.0
colnames(dat)
colnames(dat)[var.ind]
d<-data.frame(dat, dat, dat)
colnames(d)
var.ind2<-c(3,4,5,6)
colnames(d)[var.ind2]
v<-c("Intercept", colnames(d)[var.ind2])
v
setnames(alpha)
set.names(alpha)
setNames(alpha)
linVarReg<-function(dat, var.ind=c(2), mean.ind=c(2), para.space=FALSE, eps=1e-6, maxit=1000){
if (para.space==FALSE || para.space=="negative" || para.space=="positive"){
#print("OK")
}else{stop("para.space not appropriately defined. See help.")
}
loops<-list()
ll<-vector()
X<-dat[,1]
n<-length(X)
totalx<-var.ind
if (is.null(mean.ind[1])==TRUE){
meanmodel<-NULL
}else if(mean.ind[1]==0){
meanmodel<-FALSE
}else if (mean.ind[1]>0){
meanmodel<-data.frame(dat[,mean.ind])
}
### constant variance first
if (var.ind[1]==FALSE){
loops[[1]]<-loop_em(meanmodel, theta.old=1, p.old=rep(1, n), x.0=NULL, X, maxit, eps)
var<- rep(loops[[1]]$theta.new, n)
ll<- -n/2*log(2*pi)-1/2*sum(log(var))-sum(((X-loops[[1]]$fitted)**2)/(2*(var)))
if (loops[[1]]$conv==FALSE){
writeLines(paste("Warning: Did not converge at Maxit=", maxit))
}
##variance model option
}else{
## set parameters
minmax<-list()
x<-as.matrix(dat[,var.ind])
theta.old<-rep(1, 1+length(var.ind))
minmax[[1]]<-c("Min", "Max")
##find all combinations that need to be performed
if (para.space==FALSE){
comb<-expand.grid(rep(minmax, times=length(var.ind)))
}else if(para.space=="negative"){
comb<-as.data.frame(matrix(c(rep("Min", length(rep))), 1, length(totalx), byrow=TRUE))
}else if(para.space=="positive"){
comb<-as.data.frame(matrix(c(rep("Max", length(rep))), 1, length(totalx), byrow=TRUE))
}
for (i in 1:nrow(comb)){
p.old<-rep(theta.old[1], n)
x.0<-matrix(NA, ncol=ncol(x), nrow=nrow(x) )
for (j in 1:ncol(comb)){
if(comb[i,j]=="Min"){
x.0[,j]<-x[,j]-min(x[,j])
p.old<-p.old+(theta.old[j]*x.0[,j])
}
if(comb[i,j]=="Max"){
x.0[,j]<-max(x[,j])-x[,j]
p.old<-p.old+(theta.old[j]*x.0[,j])
}
}
loops[[i]]<-loop_em(meanmodel, theta.old, p.old, x.0, X, maxit, eps)
ll[i]<- -n/2*log(2*pi)-1/2*sum(log(loops[[i]]$p.old))-sum(((X-loops[[i]]$fittedmean)**2)/(2*(loops[[i]]$p.old)))
if (loops[[i]]$conv==FALSE){
writeLines(paste("Warning: Did not converge at maxit=", maxit))
}
}
}
##find highest LL for both constant and nonconstant!
max.ll<-which.max(ll)
alpha<-vector()
##save all estimates
alpha[1]<- loops[[max.ll]]$theta.new[1]
conv.final<-loops[[max.ll]]$conv
it.final<-loops[[max.ll]]$it
reldiff.final<-loops[[max.ll]]$reldiff
ll.final<-ll[[max.ll]]
mean<-loops[[max.ll]]$mean
if (var.ind!=FALSE){
for (j in 1:ncol(comb)){
if(comb[max.ll,j]=="Min"){
alpha[1]<-alpha[1]-loops[[max.ll]]$theta.new[j+1]*min(x[,j])
alpha[j+1]<- loops[[max.ll]]$theta.new[j+1]
}
if(comb[max.ll,j]=="Max"){
alpha[1]<-alpha[1]+loops[[max.ll]]$theta.new[j+1]*max(x[,j])
alpha[j+1]<- -loops[[max.ll]]$theta.new[j+1]
}
}
}
names(alpha)<-c("Intercept", colnames(dat)[var.ind])
names(mean)<-c("Intercept", colnames(dat)[mean.ind])
if (is.null(mean.ind[1])==TRUE){
#print("test param")
param<-length(totalx)+1
}else if (mean.ind[1]==0){
param<-1+length(totalx)+1
}else{
param<-length(mean.ind)+1+length(totalx)+1
}
if (sum(as.integer(loops[[max.ll]]$p.old < eps))>0){
boundary=TRUE
}else{
boundary=FALSE
}
aicc<-(2*(param)*n)/(n-(param)-1)-2*ll.final
aic<-2*(param)-2*ll.final
bic<-log(n)*(param)-2*ll.final
hqc<-log(log(n))*(param)-2*ll.final
list(conv=conv.final,iterations=it.final,reldiff=reldiff.final, loglikelihood=ll.final, boundary=boundary, AICc=aicc, AIC=aic,BIC=bic,HQC=hqc,mean.ind=mean.ind,mean=mean,var.ind=var.ind, variance=alpha, data=dat)
}
linmodel<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=c(2))
linmodel
