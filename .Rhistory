var.ind<-which(colnames(alldat)%in%colnames(bvar))
}else if (varmodel=="linear"){
var.ind<-2
if (mono.var=="inc"){
para.space<-"positive"
}else if (mono.var=="inc"){
para.space<-"negative"
}
}else if (varmodel=="constant"){
var.ind<-FALSE
}
result<-linVarReg(alldat, var.ind=var.ind, mean.ind=mean.ind, para.space=para.space, eps=eps, maxit=maxit)
model<-list(knots.m=knots.m, knots.v=knots.v, degree=degree, meanmodel=meanmodel, varmodel=varmodel)
result<-c(model, result)
return(result)
}
#' Linear mean and variance regression
#'
#' \code{linVarReg} performs multivariate mean and multivariate variance regression.
#' @param dat Dataframe containing outcome and covariate data. Outcome data must be in the first column. Covariates for mean and variance model in next columns.
#' @param var.ind Vector containing the column numbers of the data in 'dat' to be fit as covariates in the variance model. FALSE indicates constant variance option.
#' @param mean.ind Vector containing the column numbers of the data in 'dat' to be fit as covariates in the mean model. 0 indicates constant mean option. NULL indicates zero mean option.
#' @param para.space Parameter space to search for variance parameter estimates. "positive" means only search positive parameter space, "negative" means search only negative parameter space and "all" means search all.
#' @param maxit Number of maximum iterations for the EM algorithm, default 1000.
#' @param eps Very small number for the convergence criteria, default 1 times 10 power6
#' @return $linVarReg$ returns an object of class "VarReg" which inherits some components from the class "glm".
#'
#' A list of the results from the algorithm, including conv, reldiff, information criterion and mean and variance estimates.
#'@examples
#'data(lidar)
#'lid<-data.frame(lidar$logratio, lidar$range)
#'##Fit model with range as a covariate in the mean and the variance model
#'linmodel<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=c(2), para.space="all")
#'##Give more iterations to converge
#'linmodel<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=c(2), maxit=10000, para.space="all")
#'##Fit model with range as variate in variance model only - constant mean model.
#'conmean<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=0, para.space="all")
#'@export
linVarReg<-function(dat, var.ind=c(2), mean.ind=c(2), para.space=c("all", "positive", "negative"), eps=1e-6, maxit=1000){
para.space<-match.arg(para.space)
loops<-list()
ll<-vector()
X<-dat[,1]
n<-length(X)
totalx<-var.ind
if (is.null(mean.ind[1])==TRUE){
meanmodel<-NULL
}else if(mean.ind[1]==0){
meanmodel<-FALSE
}else if (mean.ind[1]>0){
meanmodel<-data.frame(dat[,mean.ind])
}
### constant variance first
if (var.ind[1]==FALSE){
loops[[1]]<-loop_em(meanmodel, theta.old=1, p.old=rep(1, n), x.0=NULL, X, maxit, eps)
var<- rep(loops[[1]]$theta.new, n)
ll<- -n/2*log(2*pi)-1/2*sum(log(var))-sum(((X-loops[[1]]$fitted)**2)/(2*(var)))
if (loops[[1]]$conv==FALSE){
writeLines(paste("Warning: Did not converge at Maxit=", maxit))
}
##variance model option
}else{
## set parameters
minmax<-list()
x<-as.matrix(dat[,var.ind])
theta.old<-rep(1, 1+length(var.ind))
minmax[[1]]<-c("Min", "Max")
##find all combinations that need to be performed
if (para.space=="all"){
comb<-expand.grid(rep(minmax, times=length(var.ind)))
}else if(para.space=="negative"){
comb<-as.data.frame(matrix(c(rep("Max", length(rep))), 1, length(totalx), byrow=TRUE))
}else if(para.space=="positive"){
comb<-as.data.frame(matrix(c(rep("Min", length(rep))), 1, length(totalx), byrow=TRUE))
}
for (i in 1:nrow(comb)){
p.old<-rep(theta.old[1], n)
x.0<-matrix(NA, ncol=ncol(x), nrow=nrow(x) )
for (j in 1:ncol(comb)){
if(comb[i,j]=="Min"){
x.0[,j]<-x[,j]-min(x[,j])
p.old<-p.old+(theta.old[j]*x.0[,j])
}
if(comb[i,j]=="Max"){
x.0[,j]<-max(x[,j])-x[,j]
p.old<-p.old+(theta.old[j]*x.0[,j])
}
}
loops[[i]]<-loop_em(meanmodel, theta.old, p.old, x.0, X, maxit, eps)
ll[i]<- -n/2*log(2*pi)-1/2*sum(log(loops[[i]]$p.old))-sum(((X-loops[[i]]$fittedmean)**2)/(2*(loops[[i]]$p.old)))
if (loops[[i]]$conv==FALSE){
writeLines(paste("Warning: Did not converge at maxit=", maxit))
}
}
}
##find highest LL for both constant and nonconstant!
max.ll<-which.max(ll)
alpha<-vector()
##save all estimates
alpha[1]<- loops[[max.ll]]$theta.new[1]
conv.final<-loops[[max.ll]]$conv
it.final<-loops[[max.ll]]$it
reldiff.final<-loops[[max.ll]]$reldiff
ll.final<-ll[[max.ll]]
mean<-loops[[max.ll]]$mean
if (var.ind[1]!=FALSE){
for (j in 1:ncol(comb)){
if(comb[max.ll,j]=="Min"){
alpha[1]<-alpha[1]-loops[[max.ll]]$theta.new[j+1]*min(x[,j])
alpha[j+1]<- loops[[max.ll]]$theta.new[j+1]
}
if(comb[max.ll,j]=="Max"){
alpha[1]<-alpha[1]+loops[[max.ll]]$theta.new[j+1]*max(x[,j])
alpha[j+1]<- -loops[[max.ll]]$theta.new[j+1]
}
}
}
names(alpha)<-c("Intercept", colnames(dat)[var.ind])
if (is.null(mean.ind)==FALSE){
names(mean)<-c("Intercept", colnames(dat)[mean.ind])
}
if (is.null(mean.ind[1])==TRUE){
#print("test param")
param<-length(totalx)+1
}else if (mean.ind[1]==0){
param<-1+length(totalx)+1
}else{
param<-length(mean.ind)+1+length(totalx)+1
}
if (sum(as.integer(loops[[max.ll]]$p.old < eps))>0){
boundary=TRUE
}else{
boundary=FALSE
}
aicc<-(2*(param)*n)/(n-(param)-1)-2*ll.final
aic<-2*(param)-2*ll.final
bic<-log(n)*(param)-2*ll.final
hqc<-log(log(n))*(param)-2*ll.final
fit<- list(converged=conv.final,iterations=it.final,reldiff=reldiff.final, loglik=ll.final, boundary=boundary, aic.c=aicc, aic=aic,bic=bic,hqc=hqc,mean.ind=mean.ind,mean=mean,var.ind=var.ind, variance=alpha, data=dat)
class(fit) <- c("VarReg")
return(fit)
}
#' Searches for best semi parametric mean and variance regression
#'
#' \code{searchVarReg} performs multiple semiparametric mean and variance regression models for a covariate of interest. The best model is chosen based on the information criterion of preference. At the moment, this is only designed for a single covariate that is fit in the mean and variance models.
#' @param y Vector containing outcome data. Must be no missing data.
#' @param x Vector containing the covariate data. Must be no missing data.
#' @param maxknots.m  A integer indicating the maximum number of internal knots to be fit in the mean model. Default is '5'. (Note that the knots are placed equidistantly over x.)
#' @param maxknots.v A integer indicating the maximum number of internal knots to be fit in the variance model. Default is '5'. (Note that the knots are placed equidistantly over x.)
#' @param degree The degree of the splines fit in the mean and variance. Default is '2'.
#' @param mono.var Indicates whether the variance model is monotonic (only applied to 'linear' or splines variance models). Default is 'none' (no monotonic constraints). Options are 'inc' for increasing or 'dec' for decreasing.
#' @param selection Indicates which information criteria is to be used for the selection of the best model. Choices are 'AIC', 'AICc', 'HQC', 'BIC'.
#' @param maxit Number of maximum iterations for the EM algorithm, default 1000.
#' @param eps Very small number for the convergence criteria, default 1 times 10 power6
#' @return $searchVarReg$ returns an object of class "VarReg" which inherits some components from the class "glm".
#'
#' A list of the results from the algorithm, including conv, reldiff, information criterion and mean and variance estimates.
#'@examples
#'data(lidar)
#'find<-searchVarReg(lidar$logratio, lidar$range, maxknots.v=3, maxknots.m=3, mono.var="none", selection="HQC", maxit=100)
#'@export
searchVarReg<-function(y,x, maxknots.m=3, maxknots.v=3, degree=2, mono.var=c("none", "inc", "dec"), selection=c("AIC", "AICc", "HQC", "BIC"), eps=1e-6, maxit=1000){
selection<-match.arg(selection)
if (length(y)!=length(x)){
stop("Error: x and y not same length")
}
if (length(maxknots.m)>1 || length(maxknots.v)>1){
stop("Error: maxknots.m or maxknots.v greater than length 1")
}
n<-length(y)
m<-list()
col.n<-paste("Mean", c("zero", "constant", "linear", paste("Knot",seq(0,maxknots.m), sep="")), sep="_")
row.n<-paste("Var", c("constant", "linear", paste("Knot",seq(0,maxknots.v), sep="")), sep="_")
aic<-matrix(NA, ncol=maxknots.m+4,nrow=maxknots.v+3, dimnames=list(row.n, col.n))
aicc<-matrix(NA, ncol=maxknots.m+4,nrow=maxknots.v+3, dimnames=list(row.n, col.n))
bic<-matrix(NA, ncol=maxknots.m+4,nrow=maxknots.v+3, dimnames=list(row.n, col.n))
hqc<-matrix(NA, ncol=maxknots.m+4,nrow=maxknots.v+3, dimnames=list(row.n, col.n))
ll<-matrix(NA, ncol=maxknots.m+4,nrow=maxknots.v+3, dimnames=list(row.n, col.n))
rep<-0
for (i in 1:(maxknots.m+4)){
if (i==1){
meanmodel<-"zero"
knots.m=NULL
}else if (i==2){
meanmodel<-"constant"
}else if (i==3){
meanmodel<-"linear"
}else if (i>3){
meanmodel<-"semi"
knots.m<-i-4
}
for (j in 1:(maxknots.v+3)){
if (j==1){
varmodel<-"constant"
knots.v=NULL
}else if (j==2){
varmodel<-"linear"
}else if (j>2){
varmodel<-"semi"
knots.v<-j-3
}
rep<-rep+1
#print(paste("rep", rep))
#print(paste("mean =", i, "   var=", j ))
param<-i-1+j
#print(paste("parameters", param))
log <- capture.output({
m[[rep]]<-semiVarReg(y=y,x=x, meanmodel=meanmodel, varmodel=varmodel,knots.m=knots.m, knots.v=knots.v,degree=degree, mono.var = mono.var, maxit=maxit,eps=eps)
})
m[[rep]]$pos<-c(j,i)
ll[j,i]<-m[[rep]]$loglik
aicc[j,i]<-(2*(param)*n)/(n-(param)-1)-2*m[[rep]]$loglik
aic[j,i]<-(2*(param))-2*m[[rep]]$loglik
bic[j,i]<-log(n)*param-2*m[[rep]]$loglik
hqc[j,i]<-log(log(n))*param-2*m[[rep]]$loglik
}
}
if (selection=="BIC"){
t<-which(bic == min(bic, na.rm=TRUE), arr.ind=TRUE)
}else if (selection=="AICc"){
t<-which(aicc == min(aicc, na.rm=TRUE), arr.ind=TRUE)
}else if (selection=="AIC"){
t<-which(aic == min(aic, na.rm=TRUE), arr.ind=TRUE)
}else if (selection=="HQC"){
t<-which(hqc == min(hqc, na.rm=TRUE), arr.ind=TRUE)
}
best.model<-list()
for (r in 1:rep){
if (m[[r]]$pos[1]==t[1] & m[[r]]$pos[2]==t[2]){
best.model<-m[[r]]
break
}
}
list(ll=ll, AIC=aic, AICc=aicc,BIC=bic,HQC=hqc, best.model=best.model)
}
model1<-searchVarReg(y=lidar$logratio, x=lidar$range,maxknots.m=2, maxknots.v=2,mono.var="none", selection="AIC", maxit=10)
model1
#' SE for mean and variance regression
#'
#' \code{se.VarReg} calculates SE for an object from a linVarReg. If the result is not on a boundary, the Fishers Information matrix SE are given. The bootstrapped 95% CI can also be calculated.
#' @param object of class VarReg of output to determin the SE
#' @param boot TRUE or FALSE indicating if bootstrapped CI should be calculated. Default is FALSE.
#' @param bootreps Number of bootstraps to be performed if boot=TRUE. Default is 1000.
#' @return Table of results.
#'@examples
#'data(lidar)
#'lid<-data.frame(lidar$logratio, lidar$range)
#'##Fit model with range as a covariate in the mean and the variance model
#'linmodel<-linVarReg(dat=lidar, var.ind=c(2),mean.ind=c(2), maxit=10000)
#'##Calculate SE
#'
#'@export
seVarReg<-function(x, boot=FALSE, bootreps=1000, eps=1e-6, maxit=1000){
n<-length(x$data[,1])
if (x$boundary==TRUE){
print("As boundary==TRUE, SE must be obtained by bootstrapping")
}else if (x$boundary==FALSE){
pred.var<-colSums(t(data.frame(rep(1, nrow(x$data)), x$data[,x$var.ind]))*x$variance)
if (x$varmodel=="constant"){
exp.i.var<- 1/2*sum(1/(pred.var**2))
inv.alpha<-tryCatch({
solve(exp.i.var, tol=1e-28)
},error=function(cond){
message("Failed to calculate the Inverse expected I-matrix for the variance")
return(matrix(NA, nrow=(length(x$var.ind)+1), ncol=(length(x$var.ind)+1)))
})
}else {
#matrix for variance
exp.i.var<-matrix(NA, nrow=(length(x$var.ind)+1), ncol=(length(x$var.ind)+1))
for (j in 1:(length(x$var.ind)+1)){
for (k in 1:(length(x$var.ind)+1)){
if (j==1){
if (k==1){
##intercept
exp.i.var[1,1]<- 1/2*sum(1/(pred.var**2))
}else{
##first column
exp.i.var[k,1]<- 1/2*sum(x$data[,x$var.ind[k-1]]/(pred.var**2))
}
}else if (k==1){
##first row
exp.i.var[1,j]<- 1/2*sum(x$data[,x$var.ind[j-1]]/(pred.var**2))
}else{
#remains of the matrix
exp.i.var[k,j]<-1/2*sum(x$data[,x$var.ind[k-1]]*(x$data[,x$var.ind[j-1]])/(pred.var**2))
}
}
}
inv.alpha<-tryCatch({
solve(exp.i.var, tol=1e-28)
},error=function(cond){
message("Failed to calculate the Inverse expected I-matrix for the variance")
return(matrix(NA, nrow=(length(x$var.ind)+1), ncol=(length(x$var.ind)+1)))
})
}
if (x$meanmodel=="zero"){
pred.mean<-rep(0, nrow(x$data))
inv.beta=NULL
}else if (x$meanmodel=="constant"){
pred.mean<-colSums(t(data.frame(rep(1, nrow(x$data)), x$data[,x$mean.ind]))*x$mean)
exp.i.mean<- sum(1/(pred.var))
inv.beta<-tryCatch({
solve(exp.i.mean, tol=1e-28)
},error=function(cond){
message("Failed to calculate the Inverse expected I-matrix for the mean")
return(matrix(NA, nrow=(length(x$mean.ind)+1), ncol=(length(x$mean.ind)+1)))
})
}else {
pred.mean<-colSums(t(data.frame(rep(1, nrow(x$data)), x$data[,x$mean.ind]))*x$mean)
exp.i.mean<-matrix(NA, nrow=(length(x$mean.ind)+1), ncol=(length(x$mean.ind)+1))
for (j in 1:(length(x$mean.ind)+1)){
# print(c("J", j))
for (k in 1:(length(x$mean.ind)+1)){
# print(c("K", k))
if (j==1){
if (k==1){
exp.i.mean[1,1]<- sum(1/(pred.var))
}else{
exp.i.mean[k,1]<- sum(x$data[,x$mean.ind[k-1]]/pred.var)
}
}else if (k==1){
exp.i.mean[1,j]<- sum(x$data[,x$mean.ind[j-1]]/pred.var)
}else{
exp.i.mean[k,j]<- sum((x$data[,x$mean.ind[k-1]]*x$data[,x$mean.ind[j-1]])/pred.var)
}
}
}
inv.beta<-tryCatch({
solve(exp.i.mean, tol=1e-28)
},error=function(cond){
message("Failed to calculate the Inverse expected I-matrix for the mean")
return(matrix(NA, nrow=(length(x$mean.ind)+1), ncol=(length(x$mean.ind)+1)))
})
}
}
if (boot==TRUE){
m.reps<-matrix(NA,bootreps,length(x$mean),dimnames=list(seq(1,bootreps, by=1),names(x$mean)))
v.reps<-matrix(NA, bootreps,length(x$variance),dimnames=list(seq(1,bootreps, by=1),names(x$variance)))
for (b in 1:bootreps){
drep<-sample(1:n, replace=TRUE)
Yrep<-x$data[drep,1]
if (x$meanmodel=="linear"){
xrep<-x$data[drep,2]
} else if (x$meanmodel=="semi"){
xrep<-x$data[drep,2]
}
log <- capture.output({
bootmodel<-semiVarReg(y=Yrep,x=xrep, meanmodel=x$meanmodel, varmodel=x$varmodel, knots.m=x$knots.m, knots.v=x$knots.v, degree=x$degree, mono.var=x$mono.var, eps=eps, maxit=maxit)
})
m.reps[b,]<-bootmodel$mean
v.reps[b,]<-bootmodel$variance
}
}
if (x$meanmodel=="zero"){
m.estimates<-NULL
}else{
m.estimates<-matrix(NA, nrow=length(x$mean), ncol=5, dimnames=list(names(x$mean), c("Estimate", "se.im", "se.boot", "lci.boot", "uci.boot")))
m.estimates[,1]<-x$mean
m.estimates[,2]<-diag(inv.beta)
if (boot==TRUE){
m.estimates[,3]<-apply(m.reps, 2, function(x) sd(x, na.rm=TRUE))
m.estimates[,4]<-apply(m.reps, 2, function(x) quantile(x, prob=0.025, na.rm=TRUE))
m.estimates[,5]<-apply(m.reps, 2, function(x) quantile(x, prob=0.975, na.rm=TRUE))
}
}
v.estimates<-matrix(NA, nrow=length(x$variance), ncol=5, dimnames=list(names(x$variance), c("Estimate", "se.im", "se.boot", "lci.boot", "uci.boot")))
v.estimates[,1]<-x$variance
v.estimates[,2]<-diag(inv.alpha)
if (boot==TRUE){
v.estimates[,3]<-apply(v.reps, 2, function(x) sd(x, na.rm=TRUE))
v.estimates[,4]<-apply(v.reps, 2, function(x) quantile(x, prob=0.025, na.rm=TRUE))
v.estimates[,5]<-apply(v.reps, 2, function(x) quantile(x, prob=0.975, na.rm=TRUE))
}
list(mean.est=m.estimates, variance.est=v.estimates, mean.im=inv.beta, variance.im=inv.alpha)
}
model1se<-seVarReg(model1$best.model, boot=TRUE, bootreps=10)
model1se
model2<-searchVarReg(y=lidar$logratio, x=lidar$range,maxknots.m=2, maxknots.v=2,mono.var="none", selection="BIC",maxit=10)
model2
model2se<-seVarReg(model2$best.model, boot=TRUE, bootreps=10)
model2se
model3<-searchVarReg(y=lidar$logratio, x=lidar$range,maxknots.m=2, maxknots.v=2,mono.var="none", selection="HQC",maxit=10)
model3se<-seVarReg(model3$best.model, boot=TRUE, bootreps=10)
model3$HQC
model3se
model4<-searchVarReg(y=lidar$logratio, x=lidar$range,maxknots.m=2, maxknots.v=2,mono.var="inc", selection="HQC",maxit=10)
model4se<-seVarReg(model4$best.model, boot=TRUE, bootreps=10)
model4se
model5<-searchVarReg(y=lidar$logratio, x=lidar$range,maxknots.m=2, maxknots.v=2,mono.var="dec", selection="HQC",maxit=10)
model5$best.model
model5se<-seVarReg(model5$best.model, boot=TRUE, bootreps=10)
model5se
devtools::document()
devtools::document()
library(VarReg)
library(VarReg)
devtools::document()
library(VarReg)
?searchVarReg
CI=TRUE
class(CI)
is.logical(CI)
CI<-1
is.logical(CI)
class(model1$best.model)
data(lidar)
linmodel<-semiVarReg(lidar$logratio, lidar$range, meanmodel="linear", varmodel="linear")
library(VarReg)
devtools::document()
devtools::document()
devtools::build()
library(VarReg)
devtools::document()
library(devtools)
devtools::document()
?path
get.path
get.path()
library(VarReg)
library(VarReg)
devtools::document()
?lidar
?lidar
devtools::document()
?lidar
library(VarReg)
library(VarReg)
devtools::document()
library(VarReg)
devtools::document()
library(VarReg)
?plotVarReg
devtools::document()
library(VarReg)
devtools::document()
?plotVarReg
library(VarReg)
devtools::document()
?plotVarReg
library(VarReg)
library(VarReg)
devtools::document()
library(VarReg)
linmodel<-semiVarReg(lidar$logratio, lidar$range, meanmodel="linear", varmodel="linear")
x<-linmodel
?plotVarReg
n<-length(x$data[,1])
x$data[,x$mean.ind]
pred.mean<-colSums(t(cbind(rep(1,n), x$data[,x$mean.ind]))*x$mean[,1])
pred.mean<-colSums(t(cbind(rep(1,n), x$data[,x$mean.ind]))*x$mean
)
pred.mean
browseVignettes()
library(gamlss)
install.packages("gamlss")
browseVignettes()
x$meanmodel
newx<-seq(min(x$data[x$mean.ind,]), max(x$data[x$mean.ind,]), by =(max(x$data[x$mean.ind,])- min(x$data[x$mean.ind,])/1000))
min(x$data[x$mean.ind,]
)
min(x$data[,x$mean.ind])
newx<-seq(min(x$data[,x$mean.ind]), max(x$data[,x$mean.ind]), by =(max(x$data[,x$mean.ind])- min(x$data[,x$mean.ind])/1000))
newx
newx<-seq(min(x$data[,x$mean.ind]), max(x$data[,x$mean.ind]), by =(max(x$data[,x$mean.ind])- min(x$data[,x$mean.ind]))/1000)
newx<-seq(min(x$data[,x$mean.ind]), max(x$data[,x$mean.ind]), by =(max(x$data[,x$mean.ind])- min(x$data[,x$mean.ind]))/999)
x.mean<-colSums(t(cbind(rep(1,1000), newx))*x$mean)
knots.m.mod<-bs(x$data[,2], df=(x$degree+x$knots.m), degree=x$degree)
library(splines)
knots.m.mod<-bs(x$data[,2], df=(x$degree+x$knots.m), degree=x$degree)
?plot
plot(xnew,grid.mean,type="l",lwd=3,  col="red",xlab=xlab, ylab=ylab, ylim=c(min(grid.mean), max(mean.uci)), main="Predicted mean")
pred.mean<-colSums(t(cbind(rep(1,n), x$data[,x$mean.ind]))*x$mean)
newx<-seq(min(x$data[,x$mean.ind]), max(x$data[,x$mean.ind]), by =(max(x$data[,x$mean.ind])- min(x$data[,x$mean.ind]))/999)
grid.mean<-colSums(t(cbind(rep(1,1000), newx))*x$mean)
plot(xnew,grid.mean,type="l",lwd=3,  col="red",xlab=xlab, ylab=ylab, ylim=c(min(grid.mean), max(mean.uci)), main="Predicted mean")
plot(newx,grid.mean,type="l",lwd=3,  col="red",xlab=xlab, ylab=ylab, ylim=c(min(grid.mean), max(mean.uci)), main="Predicted mean")
xlab="x"
ylab="y"
plot(newx,grid.mean,type="l",lwd=3,  col="red",xlab=xlab, ylab=ylab, ylim=c(min(grid.mean), max(mean.uci)), main="Predicted mean")
plot(newx,grid.mean,type="l",lwd=3,  col="red",xlab=xlab, ylab=ylab, ylim=c(min(grid.mean), max(grid.mean)), main="Predicted mean")
k
k=500
for (i in 1:(length(k))){
abline(v=k[i])
}
abline(v=k[i], lty=2)
plot(newx,grid.mean,type="l",lwd=3,  col="red",xlab=xlab, ylab=ylab, ylim=c(min(grid.mean), max(grid.mean)), main="Predicted mean")
for (i in 1:(length(k))){
abline(v=k[i], lty=2)
}
}
se
se<-seVarReg(x, boot=FALSE)
se
?semiVarReg
?linVarReg
devtools::document()
devtools::document()
?semiVarReg
devtools::document()
?VarReg.control
?semiVarReg
devtools::document()
devtools::document()
?VarReg.control
devtools::document()
?VarReg.control
?VarReg.control
devtools::document()
?VarReg.control
library(VarReg)
devtools::document()
